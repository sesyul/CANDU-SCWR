# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #
#CATHENA-DONJON Coupling level 2
##
# @file PyMain_lvl2mTh.py 
# 
# @author U. Le Tennier (March 2020), (rev. 02/2021 for CNL)
# 
# @brief Contain Coupling_lvl2() function that performs coupling between CATHENA and DONJON5 
# for the safety analysis of the CANDU-SCWR. 
#
# Coupling_lvl2() uses file managing functions available in PyProcs_lvl1m. The 
# algorithm is presented in IGE-379.pdf. In PyMain_lvl2mTh.py is 
# provided the function Coupling_lvl2() which performs the coupling. The global 
# architecture of the environment required is specified hereafter. This function
# takes into account the impact of reloading on Th233, Pa233 and U233 inventories.
#
# @section Environment Setup the environment
#
# Before executing Coupling_lvl2(), the user must choose or create a directory where 
# the execution will take place (so called EXEC_DIRECTORY). In this directory, several elements 
# will be placed, they are listed hereafter. Once done, the code will upload PyProcs_lvl1m that 
# contains several functions used by the main. Fortran files managing functions will be uploaded 
# from PyProcs_lvl1m  
#
# The directories architecture follows, a description of the files is given after.
#
# A) EXEC_DIRECTORY               
#      a) CA                              
#             1) TEMPLATE_CATH
#     
#      b) DJ                              
#             1) TEMPLATE_SCWR64N1Flu.x2m       
#             2) TEMPLATE_SCWR64N1Relo.x2m       
#             3) TEMPLATE_SCWR64N1Upda.x2m      
#             4) SCWR64N1Crit.c2m              
#             5) SCWR64N1MacU.c2m           
#             6) FMAP.INP      (*)              
#             7) HISTORY.INP                 
#             8) GEOCORE.INP   (*) (!)              
#             9) MATEX.INP     (*) (!)              
#            10) TRACK.INP     (*) (!)              
#            11) MACRORFL.INP  (*) (!)              
#            12) FMAP0.INP     (*) (!)              
#            13) HISTORY0.INP      (!)          
#            14) MICROFL.INP   (*)              
#            1X) DBREXXxX.INP      (!)
#
#      c) PY  
#             1) PyMain_lvl2m.py   
#             2) PyProcs_lvl1m.py            
#             3) ASCIIGetv4.py              
#             4) ASCIILenv4.py               
#             5) ASCIILibv4.py               
#             6) ASCIIOpnv4.py              
#             7) ASCIISixv4.py 
#
#      d) DISTRIBUTION
#
#      e) donjon.exe                     
#      f) cat3_6_1_1-b01.exe             
#      g) rdonjon5.bat      
#
# In order to upload the required procedures, the code automatically defines PATH_EXEC, PATH_PROC_DJ and PATH_PROC_CA which are the
# paths to EXEC_DIRECTORY, DJ and CA respectively. If the directories architecture is respected, the three paths are consistent 
# with a Coupling_lvl2() call. Otherwise, if the call to Coupling_lvl2() follows an equilibrium calculation, the STEP will be 1. 
# If the LOADMODEL is "3c", it is advised to use CYCLEREF equals to 6. If the LOADMODEL is "4c", it is advised to use CYCLEREF equals to 8.
# Only CANDU5 is usually used as TIMEMODEL. Finally, common values for INCCONVC and INCCONVD are 0.3 kg/s and 5 kW.
#  
#  @remarks
#  CA directory contains the CATHENA main input template (pre-filled) generated by WriteScriptM.CompleteWriting(n). \n
#  
#  @remarks
#  DJ directory contains the DONJON pre-filled inputs. The .x2m are the DONJON main input templates (pre-filled), TEMPLATE_SCWR64N1Flu.x2m is used for the flux calculation,
#  TEMPLATE_SCWR64N1Relo.x2m for the reloading and TEMPLATE_SCWR64N1Upda.x2m to update the fuelmap. SCWR64N1Crit.c2m is a procedure that finds out 
#  the boron quantity required to reach criticality. It calls SCWR64N1MacU.c2m to interpolate the databases DBREFXXxX.INP. \n
#  Other files in DJ) directory are DONJON data structures. (*) files are retrieved after neutronic equilibrium calculations. 
#  (!) files are only read, never updated. FMAP.INP is the fuelmap, HISTORY.INP contains important informations to carry the coupling 
#  and also several indicators such as the k_eff or the critical quantity of boron (ppmB). FMAP0.INP and HISTORY0.INP are vanilla copies 
#  of respectively FMAP.INP and HISTORY.INP. They are used if the user wants to restart coupled calculation from neutronics equilibrium.
#  Finally DBREXXxX.INP are the different multicompo objects (databases). Dependind on the way the assemblies at the edge of the core are 
#  treated. If corner and side assemblies are used, nine multicompos are required. Otherwise, only three multicompos are required. The corresponding 
#  SCWR64N1MacU.c2m should be used. \n
#  
#  @remarks
#  PY directory contains the present file, the PyProcs_lvl1m and ASCII procedures. PyProcs_lvl1m provides functions used by Coupling_lvl2.
#  ASCII procedures enable to navigate efficiently in DONJON data structures. \n
#  
#  @remarks
#  DISTRIBUTION directory is initially empty. Coupling_lvl2 fills and updates it with the last cycle solution. Then it uses the stored 
#  information to begin an iteration with the solution found during the previous cycle. If Coupling_lvl2 is interrupted, information in 
#  DISTRIBUTION can be used to recover every parameter distribution found for the last cycle. For instance, if the interruption occurs at step 6
#  of the cycle 4, DISTRIBUTION contains every information from step 6 of cycle 3 to step 5 of cycle 4. \n
#  
#  @remarks
#  The files donjon.exe and cat3_6_1_1-b01.exe are the DONJON and CATHENA executables. rdonjon5.bat is the batch file that performs 
#  the execution of donjon.exe  If a different name is used for one of the e) f) or g) item, Coupling_lvl2 must
#  must be updated (look and find for the items in the code and replace their name by the accurate one).
#
#  @section Error Error handling
#   
#   Four booleans are used : DON1_exec, DON2_exec, DON3_exec and CATH_exec. If the execution of CATHENA or DONJON goes wrong, 
#   the corresponding boolean are set to False. Then, the execution of the main program terminates and the errors are notified in the Exec_report.
#   The list of correspondance of booleans and code is given below :\n \n
#   DON1_EXEC is related to SCWR64N1Flu execution \n
#   DON2_EXEC is related to SCWR64N1Upda execution \n
#   DON3_EXEC is related to SCWR64N1Relo execution \n
#   CATH_EXEC is related to CATHENA execution      \n \n
#   Most of the time, errors come from SCWR64N1Flu because it is the first and most complicated call to DONJON in the code. A quick 
#   look at the bottom of the SCWR64N1Flu.results gives insights about out to fix the problem. If there is one typical mistake to highlight, 
#   it is the misuse of SCWR64N1MacU. If the SCWR64N1MacU placed in DJ is not consistent with the number of mixtures required, DONJON execution 
#   could crash. Particularly, if a call to more than 9 mixtures in MacU is made and the other inputs account for 9 mixtures, the code will crash. \n \n
#
#   If an error is triggered elsewhere in the code, the boolean \b errors turns True. 
#   \b errors is updated after a call to certain PyProcs procedures. Then execution of the main stops after writing the Exec_report 
#   in which insights are given about where the error happened. \n \n
#
#   Sometimes, sudden errors happen but are not related to the code. For instance, the TEMPLATE_CATH is not in CA) directory
#   and the code fails to find it. Such a case will only trigger python error messages. This error can happen after the code
#   was running for several days. No explanation can be given to this kind of bug. It is only required to restart the code where it crashed. 
#
# @section Restart How to restart
# If the coupling is interrupted, to restart you need to : \n
#   1) Clear the execution directory (remove what is not listed in the directories architecture) \n
#   2) Open HISTORY.INP file in DJ) directory \n
#   3) Look in the "Step" repertory what is the last number written \n
#   4) Call Coupling_lvl2 with the Step retrieved at \b 3) \n

# # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # # #


# Imports
import os         # Basic operations (management of files)
import shutil     # Sophisticated operations (management of files)
import time       # Time
import subprocess # Run CATHENA and DONJON 

from time import gmtime, strftime

# Import files managing functions 
PATH_PROC_PY = os.path.dirname(__file__)
PATH_EXEC    = PATH_PROC_PY[0:len(PATH_PROC_PY)-2]
PATH_PROC_DJ = PATH_EXEC+'DJ\\'
PATH_PROC_CA = PATH_EXEC+'CA\\'
os.chdir(PATH_PROC_PY+'\\')

import PyProcs_lvl1m as PyPro
from PyProcs_lvl1m import *

os.chdir(PATH_EXEC) 

# Main Coupling_lvl2
##
#   INPUTS \n
#   1) PATH_EXEC     ; str, absolute path where to execute all the operations        
#   2) PATH_PROC_DJ  ; str, absolute path where DONJON  files are stored            
#   3) PATH_PROC_CA  ; str, absolute path where CATHENA files are stored           
#   4) Step          ; int, index of current calculation step \n
#   5) CycleRef      ; int, number of cycles to simulate \n
#   6) TimeModel     ; str, how to go through each cycle, available : "CANDU1" - "CANDU2" - "CANDU3" - "REP1" - "REP1b" - "REP2" \n
#   7) LoadModel     ; str, which load model to be considered, 3 or 4 batches, available : "3c" - "4c" this information must match with the multicompos \n
#   8) IncConvC (kg/s); float, convergence criteria for the CATHENA simulations \n
#   9) IncConvD (kW)  ; float, convergence criteria for the coupled simulations \n \n
#   OUTPUTS \n
#   a) Exec_report  ; text file, execution report that is copied in the execution directory when simulation is over \n
#   b) Param_DistX  ; text files containing distributions of thermalhydraulic parameters, only returned for 
#   normal end of execution (files are created in PATH_EXEC). Note that X in Param_DistX can take values : \n
#   X = A ; Density of upward coolant (kg/m3, CaloUp Dens, DCu) ; \n
#   X = B ; Temperature of upward coolant (K, CaloUp Temp, TCu) ; \n
#   X = C ; Density of downward coolant (kg/m3, CaloDw Dens, DCd) ; \n
#   X = D ; Temperature of downward coolant (K, CaloDw Temp, TCd) ; \n
#   X = E ; Temperature of fuel (K, Fuel Temp, TF) ; \n
#   X = F ; Inner fuel ring centerline temperature (K) ; \n
#   X = G ; Outer fuel ring centerline temperature (K) ; \n
#   X = H ; Inner fuel ring cladding surface temperature (K) ; \n
#   X = I ; Outer fuel ring cladding surface temperature (K) ; \n
#   X = M ; Mass flow (kg/s). \n
def Coupling_lvl2(PATH_EXEC,PATH_PROC_DJ,PATH_PROC_CA,Step,CycleRef,TimeModel,LoadModel,IncConvC,IncConvD):
        
    # Inputs for SCWR64N1Flu
    Step      = Step    
    CycleRef  = CycleRef
    TimeModel = TimeModel
    LoadModel = LoadModel
    IncConvC  = IncConvC  
    IncConvD  = IncConvD   
    
    # Outputs of SCWR64N1Flu.x2m+, initialization 
    Reload     = 0
    Out        = 0
    CycleIndex = 1
    
    # Errors and wentgood (complementary to errors for SCWR64N1Flu)
    errors     = False
    wentgood   = True 
    
    # Good execution booleans 
    ConvC     = False
    ConvD     = False
    
    # Output 
    RoadMap = strftime("%a, %d %b %Y %H:%M:%S +0000", gmtime()) + ' \n'
    RoadMap = RoadMap + str(Step)+' Initialization done \n'
    
    CompCath  = 1
    CompCathS = 1
    
    START = time.time()

    Param_Dist     = zeros((10,1344,5))
    Param_Dist_new = zeros((10,1344,5))
    Param_DistCa   = zeros((10,336,5)) 
    MFlow_Dist     = ones((84,1))
    
    MFlow_Dist     = MFlow_Dist * 5.1   

    Param_DistA = ''
    Param_DistB = ''
    Param_DistC = ''
    Param_DistD = ''
    Param_DistE = ''
    Param_DistF = ''
    Param_DistG = ''
    Param_DistH = ''
    Param_DistI = ''
    Param_DistM = ''
    
    Param_AStore = 'CaloUp Dens distribution \n'
    Param_BStore = 'CaloUp Temp distribution \n'
    Param_CStore = 'CaloDw Dens distribution \n'
    Param_DStore = 'CaloDw Temp distribution \n'
    Param_EStore = 'Fuel   Temp distribution \n'
    Param_FStore = 'Fuel CITemp distribution \n'
    Param_GStore = 'Fuel COTemp distribution \n'
    Param_HStore = 'ISheathTemp distribution \n'
    Param_IStore = 'OSheathTemp distribution \n'
    Param_MStore = 'MassFlow    distribution \n'
    
    TimeCath = 1500.
    ConvArg  = []
    
    MaxCat = 0.
    MaxP   = 0.
    MaxTCu = 0.
    MaxTCd = 0.
    MaxTF  = 0.

    # While loop, tests Out condition, in normal execution, Out = 1 is triggered in history (SCWR64N1Flu.x2m+)
    # XXX
    while Out < 1 : 
        while ConvD == False :
            # - # - # - # - # - # - # - # - # DONJON1 # - # - # - # - # - # - # - # - #  
            
            # Import SCWR64N1Flu from Store  
            shutil.copyfile(PATH_PROC_DJ+'TEMPLATE_SCWR64N1Flu.x2m',PATH_EXEC+'SCWR64N1Flu.x2m')
            RoadMap = RoadMap + str(Step)+' SCWR64N1Flu.x2m was imported \n'
            
            # Prepare SCWR64N1Flu file
            #vvv
            (errors,wentgood) = writeN1Flu(PATH_EXEC,'SCWR64N1Flu.x2m',Step,CycleRef,TimeModel,LoadModel)
            
            if wentgood == False or errors == True :
                RoadMap = RoadMap + str(Step)+' ERROR IN writeN1Flu \n'
                RoadMap = RoadMap + str(Step)+' wentgood = '+str(wentgood)+'\n'
                END = time.time()
                RoadMap = RoadMap +'\nTime spent during execution '+str(END-START)[0:8]+' seconds \n' 
                with open(PATH_EXEC+'Exec_report.txt', 'w') as File:
                    File.write(RoadMap)
                return()
                
            else :
                RoadMap = RoadMap + str(Step)+' SCWR64N1Flu.x2m was properly prepared \n'
                
            
            #-------> Execution of SCWR64N1Flu.x2m
            start = time.time()
            
            subprocess.run([PATH_EXEC+"rdonjon5.bat", PATH_EXEC+"SCWR64N1Flu", PATH_EXEC+"DJ"])
            RoadMap = RoadMap + str(Step)+' SCWR64N1Flu.x2m execution \n'
        
            #xxxxx> Observer
            while os.path.isfile(PATH_EXEC+'SCWR64N1Flu.result') == False :
                time.sleep(1)
            
            end = time.time()    
            time.sleep(5)
            
            RoadMap = RoadMap + str(Step)+' SCWR64N1Flu.x2m end of execution \n'
            RoadMap = RoadMap +'!>> ' + str(end-start)[0:8]+' seconds spent in SCWR64N1Flu execution \n'  
                
            # Out of execution, retrieve power map                
            if os.path.isfile(PATH_EXEC+'FMAP.out') == True :
                
            # Read FuelMap file 
            #vvv  
                (Param_Dist_new,errors) = readN1Fmap(PATH_EXEC,'FMAP.out','HISTORY.out') 
            
                if errors == True :
                    RoadMap = RoadMap + str(Step)+' readN1Fmap exec, error triggered \n'
                    END = time.time()
                    RoadMap = RoadMap +'\nTime spent during execution '+str(END-START)[0:8]+' seconds \n' 
                    with open(PATH_EXEC+'Exec_report.txt', 'w') as File:
                        File.write(RoadMap)
                    return()
                    
                RoadMap = RoadMap + str(Step)+' new FMAP found and power retrieved \n'
                
            else :
                RoadMap = RoadMap + str(Step)+' new FMAP not found, error triggered \n'
                END = time.time()
                RoadMap = RoadMap +'\nTime spent during execution '+str(END-START)[0:8]+' seconds \n' 
                with open(PATH_EXEC+'Exec_report.txt', 'w') as File:
                    File.write(RoadMap)
                return()
                                    
            # Remove SCWR64N1Flu.x2m+ and SCWR64N1Flu.x2m from execution dir
            os.remove(PATH_EXEC+'SCWR64N1Flu.result')
            os.remove(PATH_EXEC+'SCWR64N1Flu.x2m')
            RoadMap = RoadMap + str(Step)+' SCWR64N1Flu.x2m(+) read and cleaned, Step ='+str(Step)+' \n'
            
            # - # - # - # - # - # - # - # - # CATHENA # - # - # - # - # - # - # - # - #        
                    
            # Treat Power_Dist to prepare CATH file
            # vvv
            (Pwr_Chn,Pwr_Coeff) = treatN1paramDC(Param_Dist_new) 
                        
            RoadMap = RoadMap + str(Step)+' Power_Dist treated \n'
            
            while ConvC == False : 
            
                # Import CATH from Store
                shutil.copyfile(PATH_PROC_CA+'TEMPLATE_CATH.INP',PATH_EXEC+'CATH.INP')
                RoadMap = RoadMap + str(Step)+' CATH.INP was imported \n'
                
                # Prepare CATH file 
                # vvv
                (errors) = writeN1CATH(PATH_EXEC,'CATH.INP',Pwr_Chn,Pwr_Coeff,MFlow_Dist,TimeCath) 
                
                if errors == True :
                    RoadMap = RoadMap + str(Step)+' writeN1CATH exec, error triggered \n'
                    END = time.time()
                    RoadMap = RoadMap +'\nTime spent during execution '+str(END-START)[0:8]+' seconds \n' 
                    with open(PATH_EXEC+'Exec_report.txt', 'w') as File:
                        File.write(RoadMap)
                    return()
                
                RoadMap = RoadMap + str(Step)+' CATH was properly prepared \n'
                
                #-------> Execution of CATH
                start = time.time() 
                subprocess.run([PATH_EXEC+"cat3_6_1_1-b01", PATH_EXEC+"CATH.INP"])  
                RoadMap = RoadMap + str(Step)+' CATH execution \n'
                
                #xxxxx> Observer
                while os.path.isfile(PATH_EXEC+'CATH.buf') == True :
                    time.sleep(1)
                
                end = time.time()
                time.sleep(5)
                
                RoadMap = RoadMap + str(Step)+' CATH end of execution \n'
                RoadMap = RoadMap +'!>> ' + str(end-start)[0:8]+' seconds spent in CATH execution \n' 
                
                # Out of execution, retrieve thermodynamic parameters map 
                if os.path.isfile(PATH_EXEC+'CATH.lis') == True : 
                
                    # Read CONV.RES
                    # vvv
                    (ConvC,MaxCat,MFlow_Dist,Param_DistM,errors) = checkN1convcath(PATH_EXEC,'CONV.RES','MFLOW.RES',IncConvC)
                    
                    RoadMap = RoadMap + str(Step)+'  => Conv Cath Param = '+str(MaxCat)+' \n'
                    print(str(Step)+'  => Conv Cath Param = '+str(MaxCat))     
                     
                    if ConvC == True :
                        # Read CATH+ file
                        # vvv
                        (Param_DistCa,errors) = readN1CATH(PATH_EXEC,'CaloUp Dens',Param_DistCa)  
                        # vvv
                        (Param_DistCa,errors) = readN1CATH(PATH_EXEC,'CaloUp Temp',Param_DistCa)  
                        # vvv
                        (Param_DistCa,errors) = readN1CATH(PATH_EXEC,'CaloDw Dens',Param_DistCa)  
                        # vvv
                        (Param_DistCa,errors) = readN1CATH(PATH_EXEC,'CaloDw Temp',Param_DistCa)  
                        # vvv
                        (Param_DistCa,errors) = readN1CATH(PATH_EXEC,'Fuel Temp',Param_DistCa)  
                    
                        (Param_Dist_new,Param_DistA,Param_DistB,Param_DistC,Param_DistD,Param_DistE,Param_DistF,Param_DistG,Param_DistH,Param_DistI)  = treatN1paramCD(Param_Dist_new,Param_DistCa) 
                        
                        if errors == True :
                            RoadMap = RoadMap + str(Step)+' readN1CATH exec, error triggered \n'
                            END = time.time()
                            RoadMap = RoadMap +'\nTime spent during execution '+str(END-START)[0:8]+' seconds \n' 
                            with open(PATH_EXEC+'Exec_report.txt', 'w') as File:
                                File.write(RoadMap)
                            return()
                        
                        else : 
                            RoadMap = RoadMap + str(Step)+' CATH+  converged  \n'
                        
                    else :
                        TimeCath += 500. 
                        RoadMap = RoadMap + str(Step)+' CATH+ did not converged, TimeCath inc of +500 :'+str(TimeCath)+'  \n'
                        RoadMap = RoadMap + str(Step)+'  => Abs Mass Flow  Diff = '+str(MaxCat)+' \n'   
                                            
                    # Clean exec directory
                    os.remove(PATH_EXEC+'CATH.lis')
                    os.remove(PATH_EXEC+'CATH.INP')
                    os.remove(PATH_EXEC+'SCWR64.rst')
                    
                    
                    newname = 'CONV'+str(Step)+str(CompCathS)+str(CompCath)+'.RES'
                    
                    #shutil.copyfile(PATH_EXEC+'CONV.RES',PATH_EXEC+newname)
                    os.remove(PATH_EXEC+'CONV.RES')
                    os.remove(PATH_EXEC+'MFLOW.RES')
                    
                    CompCath += 1
                        
                    for zz in range(1,5):
                        
                        Fid1  = 'DENSFLC'+str(zz)+'.RES'                         
                        Fid2  = 'DENSFLW'+str(zz)+'.RES' 
                        Fid3  = 'TEMPFLC'+str(zz)+'.RES'                         
                        Fid4  = 'TEMPFLW'+str(zz)+'.RES'                        
                        Fid5  = 'TWALLI'+str(zz)+'.RES'                        
                        Fid6  = 'TWALLO'+str(zz)+'.RES'                       
                        Fid7  = 'TWALLCI'+str(zz)+'.RES'                        
                        Fid8  = 'TWALLCO'+str(zz)+'.RES'                      
                        Fid9  = 'TWALLSI'+str(zz)+'.RES'                        
                        Fid10 = 'TWALLSO'+str(zz)+'.RES' 
                            
                        os.remove(PATH_EXEC+Fid1)                        
                        os.remove(PATH_EXEC+Fid2)                        
                        os.remove(PATH_EXEC+Fid3)
                        os.remove(PATH_EXEC+Fid4)
                        os.remove(PATH_EXEC+Fid5)
                        os.remove(PATH_EXEC+Fid6)
                        os.remove(PATH_EXEC+Fid7)
                        os.remove(PATH_EXEC+Fid8)
                        os.remove(PATH_EXEC+Fid9)
                        os.remove(PATH_EXEC+Fid10)
    
                    RoadMap = RoadMap + str(Step)+' CATH(+) read and cleaned \n'
                        
                else :
                    RoadMap = RoadMap + str(Step)+' CATH+ not found , error triggered \n'
                    END = time.time()
                    RoadMap = RoadMap +'\nTime spent during execution '+str(END-START)[0:8]+' seconds \n' 
                    with open(PATH_EXEC+'Exec_report.txt', 'w') as File:
                        File.write(RoadMap)
                    return()
                        
                RoadMap = RoadMap + str(Step)+' Thermodynamic parameters treated \n'
        
            (ConvD,MaxP,MaxTCu,MaxTCd,MaxTF) = checkN1convdist(Param_Dist,Param_Dist_new,IncConvD)
            
            ConvArg.append(MaxP)
            print(ConvArg)
            
            # Help convergence
            if ConvD == False :
                if CompCathS > 1 :
                    if ConvArg[CompCathS-1] > ConvArg[CompCathS-2] :
                        (Param_Dist_new,Param_DistA,Param_DistB,Param_DistC,Param_DistD,Param_DistE,Param_DistF,Param_DistG,Param_DistH,Param_DistI)  = helpconv(Param_Dist,Param_Dist_new)
            
            ConvC = False
            
            # CHEAT 
            CompCathS += 1
            
            # TO REMOVE
            if CycleIndex < 5 :
                if CompCathS == 8 :
                    ConvD = True
                    
            Param_Dist = Param_Dist_new
                
            RoadMap = RoadMap + str(Step)+'  => Abs Power  Diff = '+str(MaxP)+' \n'
            RoadMap = RoadMap + str(Step)+'  => Abs TempCu Diff = '+str(MaxTCu)+' \n'
            RoadMap = RoadMap + str(Step)+'  => Abs TempCd Diff = '+str(MaxTCd)+' \n'
            RoadMap = RoadMap + str(Step)+'  => Abs TempFu Diff = '+str(MaxTF)+' \n'
            
            print(str(Step)+'  => Abs Power  Diff = '+str(MaxP))            
            print(str(Step)+'  => Abs TempCu Diff = '+str(MaxTCu))            
            print(str(Step)+'  => Abs TempCd Diff = '+str(MaxTCd))            
            print(str(Step)+'  => Abs TempFu Diff = '+str(MaxTF))            
            print('---------------------------------------')       
                                    
            if ConvD == True :
                
                RoadMap = RoadMap + str(Step)+' distribution did converge, old FMAP need to be removed, new need to take place \n'
                
                # Remove obsolete fuelmap and history 
                if os.path.isfile(PATH_PROC_DJ+'FMAP.INP') == True : 
                    os.remove(PATH_PROC_DJ+'FMAP.INP')
                    RoadMap = RoadMap + str(Step)+' old FMAP removed \n'
                else :
                    RoadMap = RoadMap + str(Step)+' old FMAP not found, error triggered \n'
                    END = time.time()
                    RoadMap = RoadMap +'\nTime spent during execution '+str(END-START)[0:8]+' seconds \n' 
                    with open(PATH_EXEC+'Exec_report.txt', 'w') as File:
                        File.write(RoadMap)
                    return()
                    
                if os.path.isfile(PATH_PROC_DJ+'HISTORY.INP') == True :
                    os.remove(PATH_PROC_DJ+'HISTORY.INP')
                    RoadMap = RoadMap + str(Step)+' old HISTORY removed \n'
                else :
                    RoadMap = RoadMap + str(Step)+' old HISTORY not found, error triggered \n'
                    END = time.time()
                    RoadMap = RoadMap +'\nTime spent during execution '+str(END-START)[0:8]+' seconds \n' 
                    with open(PATH_EXEC+'Exec_report.txt', 'w') as File:
                        File.write(RoadMap)
                    return()  
                    
                if os.path.isfile(PATH_PROC_DJ+'MICROFL.INP') == True :
                    os.remove(PATH_PROC_DJ+'MICROFL.INP')
                    RoadMap = RoadMap + str(Step)+' old MICROFL removed \n'
                else :
                    RoadMap = RoadMap + str(Step)+' old MICROFL not found, error triggered \n'
                    END = time.time()
                    RoadMap = RoadMap +'\nTime spent during execution '+str(END-START)[0:8]+' seconds \n' 
                    with open(PATH_EXEC+'Exec_report.txt', 'w') as File:
                        File.write(RoadMap)
                    return()  
                
                # Copy new fuelmap and history 
                if os.path.isfile(PATH_EXEC+'FMAP.out') == True : 
                    shutil.copyfile(PATH_EXEC+'FMAP.out',PATH_PROC_DJ+'FMAP.INP')
                    RoadMap = RoadMap + str(Step)+' new FMAP copied in store \n'
                else :
                    RoadMap = RoadMap + str(Step)+' new FMAP not found, error triggered \n'
                    END = time.time()
                    RoadMap = RoadMap +'\nTime spent during execution '+str(END-START)[0:8]+' seconds \n' 
                    with open(PATH_EXEC+'Exec_report.txt', 'w') as File:
                        File.write(RoadMap)
                    return()
                    
                if os.path.isfile(PATH_EXEC+'HISTORY.out') == True :
                    shutil.copyfile(PATH_EXEC+'HISTORY.out',PATH_PROC_DJ+'HISTORY.INP')
                    RoadMap = RoadMap + str(Step)+' new HISTORY copied in store \n'
                else :
                    RoadMap = RoadMap + str(Step)+' new HISTORY not found, error triggered \n'
                    END = time.time()
                    RoadMap = RoadMap +'\nTime spent during execution '+str(END-START)[0:8]+' seconds \n' 
                    with open(PATH_EXEC+'Exec_report.txt', 'w') as File:
                        File.write(RoadMap)
                    return()
                    
                if os.path.isfile(PATH_EXEC+'MICROFL.out') == True :
                    shutil.copyfile(PATH_EXEC+'MICROFL.out',PATH_PROC_DJ+'MICROFL.INP')
                    RoadMap = RoadMap + str(Step)+' new MICROFL copied in store \n'
                else :
                    RoadMap = RoadMap + str(Step)+' new MICROFL not found, error triggered \n'
                    END = time.time()
                    RoadMap = RoadMap +'\nTime spent during execution '+str(END-START)[0:8]+' seconds \n' 
                    with open(PATH_EXEC+'Exec_report.txt', 'w') as File:
                        File.write(RoadMap)
                    return()
                
                # Stockpile the solution in a lasting file
                stockN1dist(PATH_EXEC,'CaloUp Dens',Step,LoadModel,Param_DistA)
                stockN1dist(PATH_EXEC,'CaloUp Temp',Step,LoadModel,Param_DistB)
                stockN1dist(PATH_EXEC,'CaloDw Dens',Step,LoadModel,Param_DistC)
                stockN1dist(PATH_EXEC,'CaloDw Temp',Step,LoadModel,Param_DistD)
                stockN1dist(PATH_EXEC,'Fuel   Temp',Step,LoadModel,Param_DistE)
                stockN1dist(PATH_EXEC,'Fuel CITemp',Step,LoadModel,Param_DistF)
                stockN1dist(PATH_EXEC,'Fuel COTemp',Step,LoadModel,Param_DistG)
                stockN1dist(PATH_EXEC,'ISheathTemp',Step,LoadModel,Param_DistH)
                stockN1dist(PATH_EXEC,'OSheathTemp',Step,LoadModel,Param_DistI)
                stockN1dist(PATH_EXEC,'MassFlow   ',Step,LoadModel,Param_DistM)
                
                
                RoadMap = RoadMap + str(Step)+' solutions stockpiled \n'
                
            else : 
                RoadMap = RoadMap + str(Step)+' distribution did not converge, new FMAP need to me removed \n'
            
            # Remove new fuelmap and history from execution dir 
            os.remove(PATH_EXEC+'FMAP.out')
            RoadMap = RoadMap + str(Step)+' new FMAP deleted from execution dir \n'
                
            os.remove(PATH_EXEC+'HISTORY.out')
            RoadMap = RoadMap + str(Step)+' new HISTORY deleted from execution dir \n'
                
            os.remove(PATH_EXEC+'MICROFL.out')
            RoadMap = RoadMap + str(Step)+' new MICROFL deleted from execution dir \n'

            # Read history file 
            #vvv 
            if Step != 1 :
                (Reload,CycleIndex,Step,Out,errors) = readN1Flu(PATH_PROC_DJ,'HISTORY.INP')   
                
            else : 
                if ConvD == True :
                    Reload     = 0
                    CycleIndex = 1
                    Step       = 2
                    Out        = 0
                    
            Reload     = int(Reload)             
            CycleIndex = int(CycleIndex)             
            Step       = int(Step)
            Out        = int(Out)
            
            
            CompCath   = 1
            
            # - # - # - # - # - # - # - # - # DONJON3 # - # - # - # - # - # - # - # - #
            RoadMap = RoadMap + str(Step)+' Updating triggered \n'
            
            # Import SCWR64N1Upda from Store
            shutil.copyfile(PATH_PROC_DJ+'TEMPLATE_SCWR64N1Upda.x2m',PATH_EXEC+'SCWR64N1Upda.x2m')
            
            if   LoadModel == "3c":
                cleng = 22
            elif LoadModel == "4c":
                cleng = 18
    
            cstep = Step%cleng
    
            if cstep == 0 :
                cstep = cleng
            
            poss_acc = 'Dist_DCu_'+str(cstep)+'.INP'
            
            if os.path.isfile(PATH_EXEC+'DISTRIBUTION\\'+poss_acc) and ConvD == True :  
                
                # Retrieve the solution of a precedent cycle
                
                (Param_DistA,errors) = getN1dist(PATH_EXEC,'CaloUp Dens',Step,LoadModel)
                (Param_DistB,errors) = getN1dist(PATH_EXEC,'CaloUp Temp',Step,LoadModel)
                (Param_DistC,errors) = getN1dist(PATH_EXEC,'CaloDw Dens',Step,LoadModel)
                (Param_DistD,errors) = getN1dist(PATH_EXEC,'CaloDw Temp',Step,LoadModel)
                (Param_DistE,errors) = getN1dist(PATH_EXEC,'Fuel   Temp',Step,LoadModel)
                (MFlow_Dist,errors)  = getN1mflw(PATH_EXEC,Step,LoadModel)
                
                RoadMap = RoadMap + str(Step)+' 5 useful solutions retrieved to begin the new step \n'
            
            # vvv
            errors = writeN1Upda(PATH_EXEC,'SCWR64N1Upda.x2m','CaloUp Dens',Param_DistA,Param_DistB,Param_DistC,Param_DistD,Param_DistE)                
            # vvv
            errors = writeN1Upda(PATH_EXEC,'SCWR64N1Upda.x2m','CaloUp Temp',Param_DistA,Param_DistB,Param_DistC,Param_DistD,Param_DistE)                
            # vvv
            errors = writeN1Upda(PATH_EXEC,'SCWR64N1Upda.x2m','CaloDw Dens',Param_DistA,Param_DistB,Param_DistC,Param_DistD,Param_DistE)                
            # vvv
            errors = writeN1Upda(PATH_EXEC,'SCWR64N1Upda.x2m','CaloDw Temp',Param_DistA,Param_DistB,Param_DistC,Param_DistD,Param_DistE)                
            # vvv
            errors = writeN1Upda(PATH_EXEC,'SCWR64N1Upda.x2m','Fuel Temp',Param_DistA,Param_DistB,Param_DistC,Param_DistD,Param_DistE)
            
            if errors == True :
                RoadMap = RoadMap + str(Step)+' writeN1Upda exec, error triggered \n'
                END = time.time()
                RoadMap = RoadMap +'\nTime spent during execution '+str(END-START)[0:8]+' seconds \n' 
                with open(PATH_EXEC+'Exec_report.txt', 'w') as File:
                    File.write(RoadMap)
                return()
                
            RoadMap = RoadMap + str(Step)+' SCWR64N1Upda was properly prepared \n'
            
            #-------> Execution of SCWR64N1Upda.x2m
            start = time.time()            
            subprocess.run([PATH_EXEC+"rdonjon5.bat", PATH_EXEC+"SCWR64N1Upda", PATH_EXEC+"DJ"])
            RoadMap = RoadMap + str(Step)+' SCWR64N1Upda execution \n'
            
            #xxxxx> Observer 
            while os.path.isfile(PATH_EXEC+'SCWR64N1Upda.result') == False  :
                time.sleep(1)
                
            end = time.time()
            time.sleep(5)   
            
            RoadMap = RoadMap + str(Step)+' SCWR64N1Upda end of execution \n'
            RoadMap = RoadMap +'!>> ' + str(end-start)[0:8]+' seconds spent in SCWR64N1Upda execution \n' 
                            
            # Remove obsolete fuelmap, then clean 
            if os.path.isfile(PATH_EXEC+'FMAPUP.out') == True : 
                
                if os.path.isfile(PATH_PROC_DJ+'FMAP.INP') == True : 
                    os.remove(PATH_PROC_DJ+'FMAP.INP')
                    RoadMap = RoadMap + str(Step)+' old FMAP removed \n'
                else :
                    RoadMap = RoadMap + str(Step)+' old FMAP not found, error triggered \n'
                    END = time.time()
                    RoadMap = RoadMap +'\nTime spent during execution '+str(END-START)[0:8]+' seconds \n' 
                    with open(PATH_EXEC+'Exec_report.txt', 'w') as File:
                        File.write(RoadMap)
                    return()

                # Copy new Fuelmap 
                shutil.copyfile(PATH_EXEC+'FMAPUP.out',PATH_PROC_DJ+'FMAP.INP')
                RoadMap = RoadMap + str(Step)+' new FMAP copied in store \n'
                
                # Remove new fuelmap from execution dir 
                os.remove(PATH_EXEC+'FMAPUP.out')
                os.remove(PATH_EXEC+'SCWR64N1Upda.result')
                os.remove(PATH_EXEC+'SCWR64N1Upda.x2m')
                
                
                RoadMap = RoadMap + str(Step)+' SCWR64N1Upda.x2m(+)(FMAPUPDA) cleaned \n'
                RoadMap = RoadMap + str(Step)  +' STEP '+str(Step) +' TO BEGIN \n'
                
            else :                
                RoadMap = RoadMap + str(Step)+' new FMAP (updating) not found, error triggered \n'
                END = time.time()
                RoadMap = RoadMap +'\nTime spent during execution '+str(END-START)[0:8]+' seconds \n' 
                with open(PATH_EXEC+'Exec_report.txt', 'w') as File:
                    File.write(RoadMap)
                return()
                                                  
        # Write thermodynamics distributions in output file 
        Param_AStore = Param_AStore + '>>Step '+str(Step-1)+' \n'
        Param_AStore = Param_AStore + Param_DistA ;
        Param_BStore = Param_BStore + '>>Step '+str(Step-1)+' \n'
        Param_BStore = Param_BStore + Param_DistB ;
        Param_CStore = Param_CStore + '>>Step '+str(Step-1)+' \n'
        Param_CStore = Param_CStore + Param_DistC ;
        Param_DStore = Param_DStore + '>>Step '+str(Step-1)+' \n'
        Param_DStore = Param_DStore + Param_DistD ;
        Param_EStore = Param_EStore + '>>Step '+str(Step-1)+' \n'
        Param_EStore = Param_EStore + Param_DistE ;
        Param_FStore = Param_FStore + '>>Step '+str(Step-1)+' \n'
        Param_FStore = Param_FStore + Param_DistF ;
        Param_GStore = Param_GStore + '>>Step '+str(Step-1)+' \n'
        Param_GStore = Param_GStore + Param_DistG ;
        Param_HStore = Param_HStore + '>>Step '+str(Step-1)+' \n'
        Param_HStore = Param_HStore + Param_DistH ;
        Param_IStore = Param_IStore + '>>Step '+str(Step-1)+' \n'
        Param_IStore = Param_IStore + Param_DistI ;
        Param_MStore = Param_MStore + '>>Step '+str(Step-1)+' \n'
        Param_MStore = Param_MStore + Param_DistM ;          
           
        print('<.>!<.>!<.>!<.>!<.>!<.>')
        print(str(Step)+'  to begin '+strftime("%a, %d %b %Y %H:%M:%S +0000", gmtime()))
          
        
        # Reset what need to be reset
        Param_Dist = zeros((10,1344,5))
        ConvD  = False 
        ConvArg  = []
            
        CompCath   = 1
        CompCathS  = 1
        TimeCath   = 1500.
        
        # - # - # - # - # - # - # - # - # DONJON2 # - # - # - # - # - # - # - # - #
        
        # If Reloading only is triggered, Reload                         
        if Reload == 1 :

            RoadMap = RoadMap + str(Step)+' Reloading triggered \n'
            
            # Import SCWR64N1Relo from Store
            shutil.copyfile(PATH_PROC_DJ+'TEMPLATE_SCWR64N1Relo.x2m',PATH_EXEC+'SCWR64N1Relo.x2m')

            # vvv
            errors = writeN1Relo(PATH_EXEC,'SCWR64N1Relo.x2m',Step,LoadModel)
            
            if errors == True :
                RoadMap = RoadMap + str(Step)+' writeN1Relo exec, error triggered \n'
                END = time.time()
                RoadMap = RoadMap +'\nTime spent during execution '+str(END-START)[0:8]+' seconds \n' 
                with open(PATH_EXEC+'Exec_report.txt', 'w') as File:
                    File.write(RoadMap)
                return()
            
            RoadMap = RoadMap + str(Step)+' SCWR64N1Relo was properly prepared \n'
            
            #-------> Execution of SCWR64N1Relo.x2m
            start = time.time()
            subprocess.run([PATH_EXEC+"rdonjon5.bat", PATH_EXEC+"SCWR64N1Relo", PATH_EXEC+"DJ"])
            
            RoadMap = RoadMap + str(Step)+' SCWR64N1Relo execution \n'
            
            #xxxxx> Observer
            while os.path.isfile(PATH_EXEC+'SCWR64N1Relo.result') == False :
                time.sleep(1)
            
            end = time.time()
            time.sleep(5)   
            
            RoadMap = RoadMap + str(Step)+' SCWR64N1Relo end of execution \n'
            RoadMap = RoadMap +'!>> ' + str(end-start)[0:8]+' seconds spent in SCWR64N1Relo execution \n' 
            
            # Remove obsolete fuelmap, then clean 
            if os.path.isfile(PATH_EXEC+'FMAPRE.out') == True : 
                
                if os.path.isfile(PATH_PROC_DJ+'FMAP.INP') == True : 
                    os.remove(PATH_PROC_DJ+'FMAP.INP')
                    RoadMap = RoadMap + str(Step)+' old FMAP removed \n'
                else :
                    RoadMap = RoadMap + str(Step)+' old FMAP not found, error triggered \n'
                    END = time.time()
                    RoadMap = RoadMap +'\nTime spent during execution '+str(END-START)[0:8]+' seconds \n' 
                    with open(PATH_EXEC+'Exec_report.txt', 'w') as File:
                        File.write(RoadMap)
                    return()

                # Copy new Fuelmap 
                shutil.copyfile(PATH_EXEC+'FMAPRE.out',PATH_PROC_DJ+'FMAP.INP')
                RoadMap = RoadMap + str(Step)+' new FMAP copied in store \n'
                
                # Remove new fuelmap from execution dir 
                os.remove(PATH_EXEC+'FMAPRE.out')
                os.remove(PATH_EXEC+'SCWR64N1Relo.result')
                os.remove(PATH_EXEC+'SCWR64N1Relo.x2m')
                
                
                RoadMap = RoadMap + str(Step)+' SCWR64N1Relo.x2m(+)(FMAPRELO) cleaned \n'
                RoadMap = RoadMap + str(Step)+' CYCLE '+str(CycleIndex) +' TO BEGIN \n'
                
            else :                
                RoadMap = RoadMap + str(Step)+' new FMAP (reloading) not found, error triggered \n'
                END = time.time()
                RoadMap = RoadMap +'\nTime spent during execution '+str(END-START)[0:8]+' seconds \n' 
                with open(PATH_EXEC+'Exec_report.txt', 'w') as File:
                    File.write(RoadMap)
                return()

                            
    # Export Exec_report if everything went good  
                 
    RoadMap = RoadMap +'\nNormal end of execution \n' 
    END = time.time()
    RoadMap = RoadMap +'Time spent during execution '+str(END-START)[0:8]+' seconds \n' 
    RoadMap = RoadMap + strftime("%a, %d %b %Y %H:%M:%S +0000", gmtime()) + ' \n'                              
    with open(PATH_EXEC+'Exec_report.txt', 'w') as File:
        File.write(RoadMap)
    
                                                      
    with open(PATH_EXEC+'CaloUpDens_report.txt', 'w') as File:
        File.write(Param_AStore)                              
    with open(PATH_EXEC+'CaloUpTemp_report.txt', 'w') as File:
        File.write(Param_BStore)                              
    with open(PATH_EXEC+'CaloDwDens_report.txt', 'w') as File:
        File.write(Param_CStore)                              
    with open(PATH_EXEC+'CaloDwTemp_report.txt', 'w') as File:
        File.write(Param_DStore)                              
    with open(PATH_EXEC+'FuelTemp_report.txt', 'w') as File:
        File.write(Param_EStore)                            
    with open(PATH_EXEC+'FuelCITemp_report.txt', 'w') as File:
        File.write(Param_FStore)                           
    with open(PATH_EXEC+'FuelCOTemp_report.txt', 'w') as File:
        File.write(Param_GStore)                            
    with open(PATH_EXEC+'SheathITemp_report.txt', 'w') as File:
        File.write(Param_HStore)                           
    with open(PATH_EXEC+'SheathOTemp_report.txt', 'w') as File:
        File.write(Param_IStore)                 
    with open(PATH_EXEC+'MassFlow_report.txt', 'w') as File:
        File.write(Param_MStore)                   
        
    return()
